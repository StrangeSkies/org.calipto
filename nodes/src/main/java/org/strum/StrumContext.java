package org.strum;

import static java.util.Collections.singleton;
import static java.util.stream.Stream.concat;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Collection;
import java.util.stream.Stream;

import org.strum.node.StrumNode;
import org.strum.node.StrumRootNode;
import org.strum.node.builtin.BuiltinNode;
import org.strum.node.intrinsic.CarNodeFactory;
import org.strum.node.intrinsic.CdrNodeFactory;
import org.strum.node.intrinsic.IntrinsicNode;
import org.strum.type.cons.ConsLibrary;
import org.strum.type.symbol.Nil;
import org.strum.type.symbol.Symbol;
import org.strum.type.symbol.SymbolIndex;

import com.oracle.truffle.api.CallTarget;
import com.oracle.truffle.api.CompilerDirectives;
import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;
import com.oracle.truffle.api.Scope;
import com.oracle.truffle.api.Truffle;
import com.oracle.truffle.api.TruffleLanguage;
import com.oracle.truffle.api.TruffleLanguage.Env;
import com.oracle.truffle.api.dsl.NodeFactory;
import com.oracle.truffle.api.frame.FrameDescriptor;
import com.oracle.truffle.api.instrumentation.AllocationReporter;
import com.oracle.truffle.api.interop.TruffleObject;
import com.oracle.truffle.api.nodes.NodeInfo;
import com.oracle.truffle.api.source.Source;

public class StrumContext {
  private static final Source BUILTIN_SOURCE = Source
      .newBuilder(StrumLanguage.ID, "", "SL builtin")
      .build();

  private final Env env;
  private final BufferedReader input;
  private final PrintWriter output;
  private final StrumDefinitionRegistry functionRegistry;
  private final StrumLanguage language;
  private final AllocationReporter allocationReporter;
  private final Iterable<Scope> topScopes; // Cache the top scopes

  private final SymbolIndex symbols = new SymbolIndex();

  public StrumContext(
      StrumLanguage language,
      TruffleLanguage.Env env,
      Collection<? extends NodeFactory<? extends IntrinsicNode>> externalIntrinsics,
      Collection<? extends NodeFactory<? extends BuiltinNode>> externalSideEffects) {
    this.env = env;
    this.input = new BufferedReader(new InputStreamReader(env.in()));
    this.output = new PrintWriter(env.out(), true);
    this.language = language;
    this.allocationReporter = env.lookup(AllocationReporter.class);
    this.functionRegistry = new StrumDefinitionRegistry(language);
    this.topScopes = singleton(
        Scope.newBuilder("global", functionRegistry.getFunctionsObject()).build());

    concat(getIntrinsics(), externalIntrinsics.stream()).forEach(this::installIntrinsic);
    concat(getSideEffects(), externalSideEffects.stream()).forEach(this::installSideEffect);
  }

  /**
   * Return the current Truffle environment.
   */
  public Env getEnv() {
    return env;
  }

  /**
   * Returns the default input, i.e., the source for the {@link SLReadlnBuiltin}.
   * To allow unit testing, we do not use {@link System#in} directly.
   */
  public BufferedReader getInput() {
    return input;
  }

  /**
   * The default default, i.e., the output for the {@link SLPrintlnBuiltin}. To
   * allow unit testing, we do not use {@link System#out} directly.
   */
  public PrintWriter getOutput() {
    return output;
  }

  /**
   * Returns the registry of all functions that are currently defined.
   */
  public StrumDefinitionRegistry getFunctionRegistry() {
    return functionRegistry;
  }

  public Iterable<Scope> getTopScopes() {
    return topScopes;
  }

  /**
   * Add all our intrinsic function implementations to the root scope. Note that
   * there are very few "built-in" functions so to speak; almost all functions
   * have in-language implementations. But for performance reasons some core
   * functionality does need to be transparently lifted into intrinsics.
   * <P>
   * This is also important for bootstrapping macro facilities, since using
   * Truffle means that this particular implementation can't aim to be
   * meta-circular/self-hosting.
   */
  private Stream<NodeFactory<? extends IntrinsicNode>> getIntrinsics() {
    return Stream.of(CarNodeFactory.getInstance(), CdrNodeFactory.getInstance());
  }

  public void installIntrinsic(NodeFactory<? extends IntrinsicNode> factory) {
    /*
     * The builtin node factory is a class that is automatically generated by the
     * Truffle DSL. The signature returned by the factory reflects the signature of
     * the @Specialization
     *
     * methods in the builtin classes.
     */
    int argumentCount = factory.getExecutionSignature().size();
    StrumNode[] argumentNodes = new StrumNode[argumentCount];
    /*
     * Builtin functions are like normal functions, i.e., the arguments are passed
     * in as an Object[] array encapsulated in SLArguments. A SLReadArgumentNode
     * extracts a parameter from this array.
     */
    for (int i = 0; i < argumentCount; i++) {
      argumentNodes[i] = new StrumReadArgumentNode(i);
    }
    /* Instantiate the builtin node. This node performs the actual functionality. */
    IntrinsicNode builtinBodyNode = factory.createNode((Object) argumentNodes);
    builtinBodyNode.addRootTag();
    /*
     * The name of the builtin function is specified via an annotation on the node
     * class.
     */
    String name = lookupNodeInfo(builtinBodyNode.getClass()).shortName();
    builtinBodyNode.setUnavailableSourceSection();

    /*
     * Wrap the builtin in a RootNode. Truffle requires all AST to start with a
     * RootNode.
     */
    StrumRootNode rootNode = new StrumRootNode(
        language,
        new FrameDescriptor(),
        builtinBodyNode,
        BUILTIN_SOURCE.createUnavailableSection(),
        name);

    /* Register the builtin function in our function registry. */
    getFunctionRegistry().register(name, Truffle.getRuntime().createCallTarget(rootNode));
  }

  private Stream<NodeFactory<? extends BuiltinNode>> getSideEffects() {
    return Stream.of();
  }

  public void installSideEffect(NodeFactory<? extends BuiltinNode> factory) {
    // TODO
    throw new UnsupportedOperationException();
  }

  public static NodeInfo lookupNodeInfo(Class<?> clazz) {
    if (clazz == null) {
      return null;
    }
    NodeInfo info = clazz.getAnnotation(NodeInfo.class);
    if (info != null) {
      return info;
    } else {
      return lookupNodeInfo(clazz.getSuperclass());
    }
  }

  /*
   * Methods for object creation / object property access.
   */
  public AllocationReporter getAllocationReporter() {
    return allocationReporter;
  }

  public static boolean isStrumObject(Object value) {
    return ConsLibrary.getFactory().getUncached().isCons(value);
  }

  /*
   * Methods for language interoperability.
   */

  public Object fromForeignValue(Object a) {
    if (a instanceof Long || a instanceof String || a instanceof Boolean) {
      return a;
    } else if (a instanceof Symbol) {
      return fromForeignSymbol(a);
    } else if (a instanceof Character) {
      return String.valueOf(a);
    } else if (a instanceof Number) {
      return fromForeignNumber(a);
    } else if (a instanceof TruffleObject) {
      return a;
    } else if (a instanceof StrumContext) {
      return a;
    } else if (a == null) {
      return Nil.NIL;
    }
    CompilerDirectives.transferToInterpreter();
    throw new IllegalStateException(a + " is not a Truffle value");
  }

  @TruffleBoundary
  private Symbol fromForeignSymbol(Object a) {
    return symbols.getSymbol(((Symbol) a).toString());
  }

  @TruffleBoundary
  private static long fromForeignNumber(Object a) {
    return ((Number) a).longValue();
  }

  public CallTarget parse(Source source) {
    return env.parsePublic(source);
  }

  /**
   * Returns an object that contains bindings that were exported across all used
   * languages. To read or write from this object the {@link TruffleObject
   * interop} API can be used.
   */
  public TruffleObject getPolyglotBindings() {
    return (TruffleObject) env.getPolyglotBindings();
  }

  public static StrumContext getCurrent() {
    return StrumLanguage.getCurrentContext();
  }
}